\section{Introduction}
Digital identity systems implement credential issuance and
presentation mechanisms so that a person (holder) can voluntarily
disclose his or her own acquired skills, professed attributes, or
completed accomplishments. Credentials are signed by issuer
authorities and encapsulated within various forms of digital proofs to
be held in digital wallets, empowering individuals to reveal only
chosen details to designated recipients, to limit data exposure and
permit a user-controlled release of information.

Such systems are known as selective disclosure and they enhance users
privacy by allowing data minimization when proving credentials.

\subsection{State of the art}

Selective disclosures are being used by nation states across the world
in their next generation identity systems, for instance EIDAS2.0 in
Europe where the European Digital Identity Wallet Architecture and
Reference Framework\cite{eudi-arf} mandates the use of
SD-JWT\cite{sd-jwt} and mDOC \cite{mdoc}. SD-JWT adopts for its
cryptography Hash-Based Message Authentication Codes (HMAC) to
generate proofs: such presentations can be traced and recent critical
feedback on the EUDI ARF\cite{troncoso} details this problem.

In North America the efforts concentrate on the adoption of the
BBS+ algorithm\cite{bbs+} leveraging its Zero Knowledge Proof
properties and applied to W3C Verifiable Credentials\cite{w3c-vc} to
obtain an higher degree of privacy by making every disclosure
unlinkable.

\subsection{Threats considered}

The different choices in data formats in these two approaches is
irrelevant in relation with cryptography, any choice between JSON Web
Tokens or W3C Verifiable Credentials does not impact the privacy
level. But the cryptography adopted determines the adequacy of a
solution to face three important threats that can render an algorithm
unsuitable to be used in real world situations.

\paragraph{Linkability}

The EUDI-ARF standard dictates that credentials \textit{issued} to a
holder, can be \textit{presented} (in the form of a verifiable
presentation) to a relying party in order to have one or more
attributes verified. Every verifiable presentation includes one or
more HMAC(s), formatted in SD-JWT: the HMACs are identical each time a
verifiable presentation is produced from a certain credential. This
makes possible for colluding relying parties, or to malicious actors,
to trace a holder's identity by collecting, exchanging and confronting
verifiable presentations (linkability). This threat appears to be well
mitigated by BBS+ through its Zero Knowledge Proof implementation.

\paragraph{Privacy breach of revocation lists}

We believe that anonymous revocations are a \textit{condicio sine qua
  non} to guarantee a sufficient level of privacy in digital
identities and credentials. There is no privacy-preserving revocation
system designed, either in EUDI-ARF, or in W3C-VC and BBS+. In case
the choice of strategy for revocation is left open to developers, the
risk for major privacy breaches may occur, for example with the
adoption of public status lists \cite{crlcomparison}. The hypotetical
use of a certificate status lists (CRL) presents issues related
primarily to privacy \cite{CRL}, because sensitive information about
holders leaks from the list. This problem is partially mitigated by
expiration dates, in cases where credentials can be short-lived
(typically less important credentials), but not applicable with
digital identification documents such as ID, driving license, passport
and social security numbers, which typically have longer or no
expiration time. Future plans for the national standards we are
observing include the adoption of ``Bitstring'' status lists
\cite{status-lists} which may grant a degree of privacy. Our approach
is that of designing a privacy-preserving revocation mechanism to
remove the leak of holder's information and allow to delegate the
governance of revocations to multiple revocation issuers which may be
different from the credential issuer.

%% - https://github.com/ministero-salute/it-dgc-verificaC19-android/issues/103
%% - https://osf.io/preprints/lawarxiv/yc6xu


\paragraph{Revocation issuer corruption}

If the choice of interactive revocation is left to a single issuer,
one may unilaterally choose to revoke credentials, without being
subject to revision or having to seek consensus with a quorum of
issuers. This situation leads to security issues in case Issuers are
corrupted and make a weaponized use of digital revocations to
persecute engaged individuals. Such a condition becomes a real concern
for journalists or activists living under dictatorial regimes that may
arbitrarily revoke their credentials, or even ID cards and
passports. Similarly, a security breach of an issuer service, would
result in similar threats. We mitigate this risk by introducing the
possibility for threshold issuance of revocation keys and by
separating the responsibility of revocation issuance and credential
issuance.

\paragraph{Feature Comparison}

\begin{table}[]
\centering
\begin{tabular}{cccc}
\hline
       & \textbf{UP} & \textbf{UR} & \textbf{TR} \\ \hline
SD-BLS & no          & yes         & yes         \\ \hline
SD-JWT & no          & wip         & no          \\ \hline
BBS+   & yes         & wip         & no          \\ \hline
\end{tabular}
\caption{feature comparison}
\label{tab:features}
\end{table}

We briefly round up on feature differences between the named selective
disclosure cryptographic schemes, as shown in table
\ref{tab:features}, mainly distinguishing between three fundamental
features:
\begin{itemize}
\item UP: Unlinkable Presentation
\item UR: Unlinkable Revocation
\item TR: Threshold Revocation
\end{itemize}

Where \emph{wip} is mentioned meaning work in progress on adoption of
bitstring status lists for unlinkable revocations.

\section{Overview}

\subsection{Key contributions}
The cryptographic scheme described in this paper, named
\textit{SD-BLS} for brevity, implements some of the properties of the
SD-JWT scheme (which can be easily encoded in mDOC format) and
proposes a novel cryptographic approach to similar data
structures. Furthermore SD-BLS proposes novel anonymous cryptographic
revocation flow for verifiable credentials, that aims to solve the
privacy issues posed by status and revocation lists.

\paragraph{Selective disclosure}
Similarly to the SD-JWT and mDOC formats, SD-BLS produces an array of
claims: the elements of the array are individually signed by the
issuer. In SD-BLS the signature(s) replace the HMAC. Using the
homomorphic properties of this curve SD-BLS enables the holder to
selectively disclose only certain issuer signed claims and produce a
\textit{presentation} that minimizes private information given to
verifiers.

\paragraph{Anonymous cryptographic revocation}
SD-BLS proposes a novel approach to credential revocation: the data
published by the revocation issuer will produce cryptographic material
that contains no information about the credential holders. The
cryptographic revocation material allows anyone to verify if an SD-BLS
proof produced by a credential holder has been revoked by one or
multiple issuers. The unlinkability, and thus anonymity of the
cryptographic revocation, allows the revocation issuer to share
revocations in public and allows anyone to verify if credentials have
been revoked.

\subsection{Applications}
In this section we present some applications and use cases for digital
identity and credentials, that could benefit from using the SD-BLS
scheme.

\paragraph{Digital identity}
The focus of the EUDI-ARF specifications is identity documents: it
defines mechanisms and data structures to issue a Personal
Identification (PID) as well as digital driving licenses. Similarly,
the US government is experimenting with W3C-VC and mDOC for
cross-states interoperable driving licenses. SD-BLS data format is
similar to SD-JWT and mDOC, offering selective disclosure and
anonymous revocation.

\paragraph{Academic credentials}
Diploma and academic credentials are among the core offerings of EBSI
as well as a primary research target of the W3C VC working group.

\paragraph{KYC/AML}
We are unaware of standardization efforts for interoperable
credentials in the fields of "Know Your Customer" (KYC) and Anti
Money-Laundering (AML) certifications. We are aware of solution
providers experimenting with W3C-VC for AML applications and believe
SD-BLS can greatly improve the governance of credential revocation,
which is a critical component for this use case.

\paragraph{Generic \textit{light} credentials}
As the digital identity and verifiable credential technologies are
maturing, they are being considered for usage in less privacy
concerning applications, such subscriptions and membership and
fidelity cards.

\paragraph{Verifiable credentials on Blockchain}
SD-BLS can be used with blockchain-based smart-contracts to activate
certain functions:
\begin{itemize}
    \item A verifiable presentation can be used by a smart-contract to
      verify if one or more holder's claim match the requirement
      needed to process a transaction.
    \item Issuers can publish their cryptographic revocation lists on
      chain, allowing smart-contracts to verify the status of a
      credential.
    \item The issuer's public keys can also be published on-chain,
      although this does not represent a novelty.
\end{itemize}

\section{Implementation}

In this section we will provide a detailed description of the
algorithm we propose for selective disclosure and unlinkable
revocation using BLS signatures.

\subsection{Notations and assumptions}

We will adopt the following notations:
\begin{itemize}

\item $\mathbb{F}_p$ is the prime finite field with $p$ elements
  (i.e. of prime order $p$);

\item $E$ denotes the (additive) group of points of the curve
  BLS12-381 \cite{bls381-12} which can be described with the
  Weierstrass form $y^2=x^3 + 16$;

\item $E_T$ represents instead the group of points of the twisted
  curve of BLS12-381, with embedding degree $k=12$. The order of
  this group is the same of that of $E$;

\end{itemize}

We also require defining the notion of a cryptographic
pairing. That is defined as a function $e:
\mathbb{G}_2\times\mathbb{G}_1\to \mathbb{G}_T$, where
$\mathbb{G}_1,\mathbb{G}_2$ and $\mathbb{G}_T$ are all groups of same
order $n$, such that satisfies the following properties:

\begin{itemize}

\item [i.] \emph{Bilinearity}, i.e. given $P_1,Q_1\in\mathbb{G}_1$
  and $P_2,Q_2\in\mathbb{G}_2$, we have
  \begin{align*}
    e(P_2,P_1+Q_1) = e(P_2,P_1)\cdot e(P_2,Q_1)   \\
    e(P_2+Q_2,P_1) = e(P_2,P_1)\cdot e(Q_2,P_1)
  \end{align*}

\item[ii.] \emph{Non-degeneracy}, meaning that for all
  $g_1\in\mathbb{G}_1, g_2\in\mathbb{G}_2$, $e(g_2,g_1)\ne
  1_{\mathbb{G}_T}$, the identity element of the group
  $\mathbb{G}_T$;

\item[iii.] \emph{ Efficiency}, so that the map $e$ is easy to
  compute;

\item[iv. ] $\mathbb{G}_1\ne \mathbb{G}_2$, and moreover, that
  there exist no efficient homomorphism between $\mathbb{G}_1$ and
  $\mathbb{G}_2$.

\end{itemize}

For the purpose of our protocol we will have $\mathbb{G}_1 = E$ and
$\mathbb{G}_2 = E_T$, and $\mathbb{G}_T\subset \mathbb{F}_{p^{12}}$ is
the subgroup containing the $n$-th roots of unity, where $n$ is the
order of the groups $E$ and $E_T$. Instead $e: E_T \times E\to
\mathbb{G}_T$ is the \emph{Miller pairing}, which in our work is
encoded as the method \verb!miller(ECP2 P, ECP Q)!. \\


\subsection{Issuance} \label{issuance}

As for other well known algorithms BLS signing will work following
three main steps:
\begin{itemize}

\item \textbf{Key Generation phase.} For an issuer who wants to sign a
  credential $m$, a secret key $sk$ is a random number chosen
  uniformly in $\mathbb{F}_n$, where $n$ is the order of the groups
  $\mathbb{G}_1, \mathbb{G}_2, \mathbb{G}_T$. The corresponding public
  key $pk$ is the element $sk\cdot G_2\in E_T$;

\item \textbf{Signing phase.} The credential $m$ is first hashed into
  the point $U\in E$, which in our scheme is done by the method
  \verb!hashtopoint!; the related signature is then given by $\sigma =
  sk\cdot U$;

\item \textbf{Verification phase.} For an other user that wants to
  verify the authenticity and the integrity of the message $m$, it
  needs to

  \begin{itemize}

  \item [1.] parse $m, pk$ and $\sigma$

  \item [2.] hash the message $m$ into the point $U$ and then
    check if the following identity holds,

    \[
    e(pk,U) = e(G_2,\sigma)
    \]

  \end{itemize}
If verification passes it means that $\sigma$ is a valid signature for
$m$.
\item \textbf{Proof of correctness} By using the definitions of the
  elements involved and exploiting the property of the pairing $e$ we
  have
\[
\begin{split}
    e(pk,U) &= e(sk\cdot G_2, U) \\
            &= e(G_2,U)^{sk}\\
            &= e(G_2,sk\cdot U)\\
            &= e(G_2,\sigma)
\end{split}
\]

\end{itemize}

BLS signatures also support aggregation: it is possible to aggregate a
collection of multiple signatures $\sigma_i$ (each one related to a
different message $m_i$) into a singular new object $\sigma$, that can
be validated using the respective public keys $pk_i$ in a suitable
way.

Since $\sigma_i\in G_1 \forall i$, the algorithm has an homomorphic
property. We exploit this property to add a revocation signature into
the signed credential.

We create a new secret key $rev$ with public key $r$ and signature of
the claim $\sigma_{rev}$ to add to the issuer signature:
\begin{equation*}\label{rev_agg}
    \begin{split}
        r &= rev \cdot G_2 \\
        \sigma_{rev} &= rev \cdot U\\
        \sigma &= sk\cdot U + \sigma_{rev}\\
   \end{split}
\end{equation*}
The set of all the signed claims will be:
\begin{equation*}
   \mathcal{C} = \big\{ \{id, r, \sigma \} : id\in claims  \big\}
\end{equation*}

At the end of this phase the holder is sent the \textit{signed claims}
to be stored in a private wallet, while the issuer stores a list of
\textit{revocations}, associated with an identifier of the holder and
the specific credential, into a private database that can be used
later to issue revocations.



\subsection{Presentation} \label{presentation}

When the holder needs to disclose a particular claim $id$ it is
sufficient to send the signed claim set $\{id, r, \sigma \}$.

\subsection{Verification}

Credential verification is made by checking the presented issuer's
signature. In order to do that the credential issuer's public key must
be added to the revocation public key.\\ As explained in section
\ref{presentation} we can consider the credential proof as a
collection of tables of the following form:
\begin{equation*}
    c_{id} = \{id, r, \sigma \}
\end{equation*}
where $\sigma$ and $r$ are respectively the signature of the string
$id$ and the revocation public key.  We can check the validity of the
presented claim computing the key
\begin{equation*}
    pk = A.pk + r
\end{equation*}
and verify the bls signature $\sigma$.

\subsubsection{Proof of correctness}
% (questa è praticamente una proof dell'homomorphic property...)
The signature $\sigma$ is given by
\begin{equation*}
\begin{split}
    \sigma &= sign(A.sk, id) + sign(rev, id) \\
     &= A.sk U + rev U
\end{split}
\end{equation*}
where $U$ is the mapping of the string $id$ in the group $G_1$.\\
Recalling the verification formula, it holds that:
\begin{equation*}
\begin{split}
 e(pk, U) &= e(A.skG_2 + revG_2, U) \\
 &= e(A.skG_2, U) \cdot e(revG_2, U) \\
 &= e(G_2, A.sk U) \cdot e(G_2, rev U) \\
 &= e(G_2, A.sk U + rev U) \\
 &= e(G_2, \sigma) \\
\end{split}
\end{equation*}
where each equality holds for the bilinearity of the Miller loop.\\

This concludes the first verification phase. If the given presentation
is valid, then the verifier should proceed to check the revocation
status of the credential as explained below.

\subsection{Revocation}

To control if a revocation has been emitted for any credential being
verified, we update the revocation list from the issuer. A revocation
list can be publicly distributed since revocation keys do not provide
any information on the identity of holders.

Given an element $c_{id} = \{id, r, \sigma \}$ of the credential
presentation and the Issuer public key $A.pk$, if the claim id is
present in the revocation list, we can take the corresponding
revocation private key $rev$.\\ We can verify the validity of the
revocation by checking if the revocation public key presented by the
holder match:
\begin{equation*}
    r = G_2 \cdot rev
\end{equation*}
This step should follow the signature verification and is sufficient
to guarantee the revocation status.

If a dishonest holder provides a wrong $r$, then the verification of
the signature will fail, and the given credential should be considered
invalid.

If it happens that the signature verification is successful and that
the revocation key does not match, one can conclude that the
credential is not revoked.

\subsection{Threshold Revocation}

In order to split responsibilities over interactive revocation we
introduce a threshold over the revocation key, plus we split the
functionality of \textit{credential issuance} from that of
\textit{revocation issuance}, now operated by different peers.

This is implemented via an interactive process facilitated by a third
party trustee, a revocation dealer, who should be:
\begin{itemize}
    \item never entitled to publish revocations
    \item connected to credential issuers to complete any credential
      signature
    \item never informed about the identity of credential holders
    \item regularly connected to revocation issuers to distribute
      shares
\end{itemize}

Such a revocation dealer will be in contact with \textit{credential
  issuers} for the signature of credentials: it will create the $rev$
revocation key while concealing it from them. The trustee then
proceeds creating the $\sigma_{rev} = rev \cdot U$ revocation
signature and the $r = rev \cdot G_2$ public key as detailed in the
issuance phase \eqref{rev_agg}. Finally the revocation trustee will
distribute $\sigma_{rev}$ and $r$ to issuers for further processing
into the final signed credential.

The revocation trustee (dealer) will then proceed asynchronously to
split the revocation key into shares using a public verifiable secret
sharing (PVSS \cite{pvss}) implementation and distribute these shares
to all revocation issuers. In order to issue a revocation, a
configurable quorum of peers among the revocation issuers will need to
reconstruct the secret revocation key and publish it.

This process separates responsibilities between the credential issuer
and the revocation issuers, delegating to the revocation issuers the
possibility to revoke a credential interactively through a collective
process.

The collection of shares can be done asynchronously and is provable.
The dealer should publish proofs of knowledge of each revocation
share, proving their creation and authenticity. Revocation issuers can
also use the dealer proofs to verify the validity of the shares
received without revealing them. Such revocation proofs will also be
useful when revocation issuers will reconstruct a revocation, since
they can refer to them to prove their shares are authentic without
revealing their content.

\section{Prevent reply attack on presentation}
{\color{blue}
	Con lo schema base presentato fino a qui un Verifier only gets the proof that the
	credential was issued by a particular Issuer and not already verified, but the credential
	itself can be replayed by anyone who gets access to it.  This means
	that, for example, after a credential was presented to an evil verifier or leacked to an attacker, the	attacker can present the credential to any other verifier.
	Per impedire questo tipo di presentazione non autorizzata si puo aggiungere altri 3 campi contenenti, informazioni sulla sessione, la loro firma e la chiave pubblica associata, abbiamo quindi:
	$$\{H,rPk,s',m,t,tSg,tPk\}$$
	Dove $t$ contiene l'intended verifier e il momento della scadenza (es: 1 minuto dopo l'emissione).\\
	Dove $s'=s+sign(tSk,H)$.\\
	
	Si vede subito come tPk, connn tutto il blocco $t,tSg,tpk$, non possa essere rimosso perché necessario alla verifica di $s'$
	Si vede subito come t non possano essere sostituito e rifirmato creando una nuova tSg perché il verifier non conosce $tSk$
	Si vede subito come dalla settupla non si puo generare un altra sestupla perché sarebbe necessario conoscere $s$, ma chi riceve le credenziali conosce vede solo $s'$. In più non è possibile ricreare $s$ conoscendo $H$ perché non si conosce $rSk$ né $aSk$ per performare le firme.
}
{\color{red}
	[per noi e basta] La soluzione fatta come così sopra dovrebbe mantenere un vantaggio a sd-jwt che questo schema già ha e che forse non abbiamo detto: non avendo un header fisso con dentro una chiave pubblica per fare questa cosa allora la presentazione di m diversi non è linkabile alla stessa chiave pubblica o, se in jwt non usi il binding con la chiave, allo stesso gruppo di informazioni
	La mia proposta di soluzione al replay attack riesce a mantenere questa proprietà di sd-bls ed è quindi migliore dell'alternativa (uguale a come fa jwt):
	$$H(m:rPk:holderPk),rPk,s,m,t,tSg,holderPk$$
}


\section{Benchmarks}

We implemented the flows for credential issuance, presentation,
verification and revocation for lab tests using
Zenroom \footnote{Zenroom home: https://zenroom.org}, a secure
isolated execution environment implementing advanced cryptography
transformations. The reference implementation for this paper is
published on a public repository \footnote{SD-BLS github repository:
https://github.com/dyne/sd-bls}. All benchmarks were executed on a 6th
gen. Intel PC running tests on a single i7 3.40GHz core and making no
use of hardware acceleration.

Lab measurements on a growing number of claims show that issuance is
less computation heavy than verification, as shown in figure
\ref{fig:issueproveverify}.

\begin{figure}
    \centering
    \includegraphics[width=1\linewidth]{issueproveverify.eps}

    \caption{Speed comparison of issue and verify}
    \label{fig:issueproveverify}
\end{figure}

Based on our benchmarks, the resulting data objects sizes, excluding the signed material which can be either of variable length or fixed length hashes, are:
\begin{itemize}
    \item Proof:  145 Bytes
    \item Revocation: 32 Bytes
\end{itemize}

The computational cost grows for the verification phase with the presence of a cryptographic revocations list. We assume that revocations are grouped by claim type or credential structure, for instance all revocations of a certain common claim (e.g.: "is above 18" or "is a Danish citizen") for any holder are published in the same list: this will not degrade the level of privacy and will group some revocations in smaller lists.

Lab measurements of the time taken by a single proof verification process to operate on a growing number of revocations demonstrate that there is a linear growth, as shown in figure \ref{fig:verifyrevocations}.

\begin{figure}
    \centering
    \includegraphics[width=1\linewidth]{verifyrevocations.eps}

    \caption{Speed of verification of a claim over multiple revocations}
    \label{fig:verifyrevocations}
\end{figure}

The threshold operated for revocation issuers consists of a verifiable secret sharing implementation supporting a configurable total and quorum of peers. Our implementation shows very good performance on reconstruction, which is the most speed-sensitive operation in scenarios where responsive revocation process is required. The process of reconstruction can be easily scaled for asynchronous consensus on a micro-service swarm architecture and verified on blockchain.

\begin{figure}
    \centering
    \includegraphics[width=1\linewidth]{pvss.eps}
    \caption{Speed of creation and reconstruction of shares among multiple peers}
    \label{fig:pvss}
\end{figure}


%---------

\section{Conclusion}
\subsection{Security considerations}

The revocations database is privacy and corruption sensitive (by our
previous definition of issuer corruption) and it should be securely
stored by each Issuer. This is mitigated by the adoption of threshold
revocation. When using threshold revocation there is still the need
for a \textit{revocation trustee} who may be a single point of failure
if allowed to publish revocation keys dishonestly collected during the
process of credential issuance.

BLS signatures and the proof system obtained with credentials are
considered secure by assuming the existence of random oracles
\cite{random-oracle}, together with the decisional Diffie-Hellman
Problem (DDH) \cite{DDH-problem}, the external Diffie-Hellman Problem
(XDH), and with the Lysyanskaya-Rivest-Sahai-Wol Problem (LRSW)
\cite{lrsw-assumption}, which are connected to the Discrete
Logarithm.

The SD-BLS implementation we are presenting in this paper is
demonstrated using the BLS12-381 curve \cite{bls381-12} also adopted
by ETH2.0. Debating the choice of BLS12-381 is beyond the scope of
this paper, but is worth mentioning that we can easily switch using
the BLS461 curve based on a 461 bit prime, hence upgrading our
implementation to 128 bit security \cite{updating-key-pairings}
against attacks looking for discrete logs on elliptic curves
\cite{discrete-log-attack}.

The future growth of quantum-computing technologies may be able to
overcome the Discrete Logarithmic assumptions by qualitatively
different computational means and SD-BLS may then be vulnerable to
quantum-computing attacks. However this is speculative reasoning on
what we can expect from the future.

The SD-BLS implementation we present in this paper doesn't integrate
any protection against replay-attacks, nor implements timestamps and
expiration. We believe security features protecting from
replay-attacks can be easily added and adapted from the context of
deployment. I absence of session management providing such
protections, any real-world use of SD-BLS should contemplate adding a
signed timestamp to presentations and expiration checks on
verifications.

\subsection{Future development}

In this section we describe possibilities for expanding the algorithm
to cover further applications, which appear promising while requiring
further investigation.

\paragraph{Compatibility with EUDI-ARF}

EUDI-ARF dictates that the holder's secret key generation and
signatures must occur inside a trusted platform module (TPM). For
mobile devices, this limits the secret keys and signatures to those
offered, via proprietary APIs by the mobile OS, namely RSA (multiple
flavours) and ECDSA on the secp256r1 curve. Currently the TPMs APIs
supported by Android and iOS do not support BLS 12381 key generation
or signature.

Client-side signatures in EUDI-ARF are mostly used in the
authentication process, specifically in the proof of possession
required by the OpenID4VCI\cite{OID4VCI} issuance flow, but not in the
verification.

Therefore, we can investigate the possibility to use SD-BLS to
implement a partially retro-compatible superset of EUDI-ARF, by
maintaining the current issuance and verification protocols and using
an extended SD-JWT format. Also we can explore useful integrations
with the European Blockchain Services Infrastructure (EBSI
\cite{ebsi}).

\paragraph{Signroom and DIDroom}

In SD-BLS both credential issuers and revocation issuers are in charge
of various interactive administrative operations, while the dealing of
revocation shares can be easily automated.

We plan to integrate SD-BLS in the free and open source software
``Signroom'', an application we developed in the context of the NGI
ASSURE grant, and ``DIDroom'' the dashboard connected to our
\emph{did:dyne} W3C DID domain.

\paragraph{Digital Product Passport}
Efforts in standardization of Digital Product Passport (DPP) are
ongoing in both the EU (Cirpass, BatteryPass, Trace4EU) and US
(DSCSA). An obstacle to adoption of DPP technologies is the reluctancy
of manufacturers to share information about their supply-chain,
knowing that the information would become publicly available and
immutable due to blockchain storage. While requiring further analysis
and investigation, a further development of the SD-BLS scheme could
allow creating DPPs built on the selective disclosure principles,
which may facilitate the adoption of the technology in the industry by
preserving the privacy of natural persons present in the DPP as REA
agents\cite{reflow}, while authenticating their contribution.

\paragraph{DAO Technologies}
The SD-BLS math is fully compatible with ETH2.0 and can be computed
inside an Ethereum VM. A verifier implemented in solidity can be a
building block for more advanced Distributed Autonomous Organizations
(DAO \cite{dao}) that want to authenticate peers using the selective
disclosure of verifiable credentials instead of a key based proof of
possession.


\section{Acknowledgements}
This work has been funded by the EU in the framework of the NGI
TRUSTCHAIN project, grant No 101093274. We thank Puria Nafisi Azizi
and Matteo Cristino for their infatiguable work on Zenroom, Luca Di
Domenico for his help on the PVSS implementation, Giuseppe De Marco
for sharing findings from his pioneering journey, Simone Onofri for
his insights on threat models and Gabriele Bellini for his helpful
security review. We extend our thanks the anonymous reviewers for
their valuable advice and the De Cifris association for facilitating
connections over a large network of unique professionals.

\bibliographystyle{IEEEtran}
\bibliography{references}

\end{document}
